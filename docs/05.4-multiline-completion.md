# Phase 5.4 — Multiline Completion (Properly)

## What we are solving (precisely)

Single-line logic is now correct.
Multiline introduces **three new failure modes**:

1. **Model repeats existing lines**
2. **Model overlaps partially with existing suffix lines**
3. **Indentation drifts or doubles**

We are _not_ doing AST parsing.
We are _not_ doing formatter-level logic.

This is **string-based structural alignment**, exactly what inline completion engines do.

---

## Rule zero (important)

> **Inline completion always inserts a delta**
> Anything already present in the buffer must be removed from the completion.

This rule applies:

- horizontally (prefix / suffix)
- vertically (previous / next lines)

---

## Step 1 — Extend the agent’s responsibility (conceptually)

Your `PrefixAlignmentAgent` is now becoming a **RangeAlignmentAgent**, but we’ll
keep the name for now to avoid churn.

New responsibilities:

| Dimension      | Remove overlap with           |
| -------------- | ----------------------------- |
| Prefix         | `context.prefix`              |
| Suffix         | `context.suffix`              |
| Previous lines | `context.previous_lines[-N:]` |
| Next lines     | `context.next_lines[:N]`      |

---

## Step 2 — Define behavior with tests (before code)

Create a new test file section:

```
tests/agents/test_prefix_alignment_agent_multiline.py
```

(or keep it in the same file if you prefer).

---

## Multiline test cases (canonical)

### ✅ 1. Model repeats existing block

**Buffer**

```python
if cond:
    |
    do_other()
```

**Model**

```python
if cond:
    do_something()
```

**Expected delta**

```python
    do_something()
```

### Test

```python
def test_multiline_removes_repeated_previous_lines():
    agent = PrefixAlignmentAgent()

    context = make_context(
        prefix="    ",
        current_line="    ",
        previous_lines=["if cond:"],
    )

    completion = "if cond:\n    do_something()"

    result = agent.after_generation(context, completion)

    assert result == "    do_something()"
```

---

### ✅ 2. Overlap with next lines (suffix lines)

**Buffer**

```python
if cond:
    do_something()
    |
    cleanup()
```

**Model**

```python
    do_other()
    cleanup()
```

**Expected delta**

```python
    do_other()
```

### Test

```python
def test_multiline_removes_overlap_with_next_lines():
    agent = PrefixAlignmentAgent()

    context = make_context(
        prefix="    ",
        current_line="    ",
        next_lines=["    cleanup()"],
    )

    completion = "    do_other()\n    cleanup()"

    result = agent.after_generation(context, completion)

    assert result == "    do_other()"
```

---

### ✅ 3. Partial overlap across lines

**Buffer**

```python
return (
    a +
    |
    b
)
```

**Model**

```python
    a +
    b
)
```

**Expected delta**

```python
    b
```

### Test

```python
def test_multiline_partial_overlap():
    agent = PrefixAlignmentAgent()

    context = make_context(
        prefix="    ",
        current_line="    ",
        previous_lines=["return (", "    a +"],
        next_lines=["    b", ")"],
    )

    completion = "    a +\n    b\n)"

    result = agent.after_generation(context, completion)

    assert result == "    b"
```

---

## Step 3 — Implementation strategy (no code yet)

We will **not** do clever diffing.

We will do **progressive trimming**:

### Algorithm (high level)

1. Split completion into lines
2. Trim from the **top**:
   - While completion starts with the tail of `previous_lines`, drop those lines

3. Trim from the **bottom**:
   - While completion ends with the head of `next_lines`, drop those lines

4. Rejoin remaining lines
5. Apply existing single-line prefix/suffix logic

This is:

- O(n)
- predictable
- debuggable
- testable

---

## Step 4 — Helper functions (design, not full code yet)

You’ll end up with helpers like:

```python
def trim_leading_line_overlap(
    completion_lines: list[str],
    previous_lines: list[str],
) -> list[str]:
    ...
```

```python
def trim_trailing_line_overlap(
    completion_lines: list[str],
    next_lines: list[str],
) -> list[str]:
    ...
```

These helpers:

- compare **normalized lines** (strip only trailing whitespace)
- preserve original indentation
- stop at first non-match

---

## Why this approach is correct

- ✅ Matches real editor behavior
- ✅ Works across languages
- ✅ No formatting side effects
- ✅ Respects cursor locality
- ✅ Incrementally extensible

And most importantly:

> **You can reason about every line removed**

No “AI magic”.

---

## What I suggest next (order matters)

**Next message**, we should:

1. Pick **one** multiline test
2. Implement just enough code to make it pass
3. Iterate test → code → test

If you want, say:

- “Let’s implement test 1”
- or “Start with overlap with next_lines”
- or “Show me the trimming helpers first”

You’re building this the _right_ way. This is no longer a toy LSP — this is real editor infrastructure now.
