# Phase 5.1 â€” Prefix Alignment Agent

## Goal

> Prevent duplicated code when the model echoes:

* the prefix
* the full current line
  **while preserving indentation**

---

## 1ï¸âƒ£ Agent responsibility (clear contract)

**Name:** `PrefixAlignmentAgent`
**Hook:** `after_generation`
**Input:** `(context, text)`
**Output:** cleaned completion text (or `None`)

This agent:

* never blocks generation
* never mutates context
* only fixes output correctness

---

## 2ï¸âƒ£ Create the agent

### `agents/prefix_alignment.py`

```python
import re
from ai_lsp.agents.base import CompletionAgent
from ai_lsp.domain.completion import CompletionContext


def _split_indent(text: str) -> tuple[str, str]:
    match = re.match(r"^(\s*)(.*)$", text)
    return match.group(1), match.group(2)


class PrefixAlignmentAgent(CompletionAgent):
    """
    Removes duplicated prefix/current line from LLM output,
    preserving indentation.
    """

    def after_generation(
        self,
        context: CompletionContext,
        text: str,
    ) -> str | None:
        prefix = context.prefix or ""
        current_line = context.current_line or ""
        completion = text or ""

        prefix_indent, prefix_code = _split_indent(prefix)
        line_indent, line_code = _split_indent(current_line)
        comp_indent, comp_code = _split_indent(completion)

        prefix_norm = prefix_code.strip()
        line_norm = line_code.strip()
        comp_norm = comp_code.lstrip()

        # Case 1: echoed prefix
        if prefix_norm and comp_norm.startswith(prefix_norm):
            remainder = comp_norm[len(prefix_norm):].lstrip()
            return prefix_indent + remainder

        # Case 2: echoed whole line
        if line_norm and comp_norm.startswith(line_norm):
            remainder = comp_norm[len(line_norm):].lstrip()
            return line_indent + remainder

        return completion
```

---

## 3ï¸âƒ£ Register the agent (engine wiring)

In `ollama_client.py`:

```python
from ai_lsp.agents.prefix_alignment import PrefixAlignmentAgent
```

And update the default agent list:

```python
self.agents = agents or [
    CompletionIntentAgent(),
    ContextPruningAgent(),
    PrefixAlignmentAgent(),  # ğŸ”§ HERE
    OutputGuardAgent(),
]
```

**Order matters**:

* alignment must happen **before** output guards
* after context pruning
* before sanitization

You already have the correct finalize flow â€” no changes needed.

---

## 4ï¸âƒ£ Why this is *architecturally correct*

* âœ… Single responsibility
* âœ… No coupling to LSP or editor
* âœ… Language-agnostic
* âœ… Easily unit-testable
* âœ… Fits perfectly into your Phase 5 agent pipeline

This is exactly how Copilot-style systems are structured.

---

# Next: Phase 5.2 â€” Multiline + Cursor-in-the-Middle

Hereâ€™s what weâ€™ll tackle next (preview):

### Problems to solve

* Cursor not at end of line
* Model returns multiple lines
* Completion overlaps existing suffix
* Indentation must adapt per line

### What weâ€™ll build

A **Range-Aware Alignment Agent** that:

* understands `context.suffix`
* trims overlapping text
* supports multiline diffs
* respects cursor position

This will require:

* extending `CompletionContext`
* updating `context_builder`
* upgrading the alignment logic (still string-based, not AST)

---

## Before we continue

Quick check so I donâ€™t guess:

ğŸ‘‰ **Do you already store the text *after* the cursor anywhere?**
(e.g. `context.suffix` or similar)

If yes, tell me the field name.
If not, weâ€™ll add it cleanly in the next step.

Youâ€™re doing this *exactly right*. This is real LSP engineering now ğŸš€
