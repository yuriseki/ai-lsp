# Phase 7.3 â€” Suffix Constraint Agent

## ğŸ¯ Goal

Analyze the **suffix (text after the cursor)** and produce **constraints** that:

* limit what the LLM is allowed to emit
* guide trimming / alignment agents
* influence range decisions later (insert vs replace)

This agent **never mutates text**.

---

## 1ï¸âƒ£ Data model

Create a new domain object.

### `domain/constraints.py`

```python
from dataclasses import dataclass
from typing import List


@dataclass
class SuffixConstraints:
    must_not_repeat: List[str]
    must_close: List[str]
    forbidden_newlines: bool
    confidence: float
```

### Meaning

| Field                | Meaning                              |
| -------------------- | ------------------------------------ |
| `must_not_repeat`    | tokens already present in suffix     |
| `must_close`         | delimiters that must remain balanced |
| `forbidden_newlines` | inline-only completion               |
| `confidence`         | how strong these constraints are     |

---

## 2ï¸âƒ£ Agent interface

### `agents/constraints.py`

```python
from ai_lsp.agents.base import CompletionAgent
from ai_lsp.domain.completion import CompletionContext
from ai_lsp.domain.constraints import SuffixConstraints


class SuffixConstraintAgent(CompletionAgent):
    def analyze(self, context: CompletionContext) -> SuffixConstraints:
        raise NotImplementedError
```

---

## 3ï¸âƒ£ Core heuristics (deterministic, cheap)

---

### 3.1 Paired delimiter constraints

We only care about **immediate suffix**, not full parsing.

```python
PAIRS = {
    ")": "(",
    "]": "[",
    "}": "{",
    '"': '"',
    "'": "'",
}
```

Logic:

```python
def _detect_closing_tokens(suffix: str) -> list[str]:
    result = []
    for char in suffix:
        if char in PAIRS:
            result.append(char)
    return result
```

This tells us:

> â€œDo not emit these closers again.â€

---

### 3.2 Inline-only constraint

If suffix contains **non-whitespace**, multiline completions are dangerous.

```python
def _forbid_newlines(suffix: str) -> bool:
    return bool(suffix.strip())
```

This prevents things like:

```python
foo(|bar)
# LLM emits a full block âŒ
```

---

### 3.3 Must-not-repeat tokens

We extract **leading tokens** from the suffix.

```python
import re

def _extract_leading_tokens(suffix: str) -> list[str]:
    tokens = re.findall(r"[\)\]\};,]+", suffix)
    return tokens[:1] if tokens else []
```

Example:

| Suffix | Tokens |
| ------ | ------ |
| `);`   | `)`    |
| `],`   | `]`    |
| `}`    | `}`    |

---

## 4ï¸âƒ£ Full agent implementation

```python
class SuffixConstraintAgent(CompletionAgent):
    def analyze(self, context: CompletionContext) -> SuffixConstraints:
        suffix = context.suffix or ""

        must_close = _detect_closing_tokens(suffix)
        forbidden_newlines = _forbid_newlines(suffix)
        must_not_repeat = _extract_leading_tokens(suffix)

        confidence = 0.9 if suffix.strip() else 0.5

        return SuffixConstraints(
            must_not_repeat=must_not_repeat,
            must_close=must_close,
            forbidden_newlines=forbidden_newlines,
            confidence=confidence,
        )
```

---

## 5ï¸âƒ£ Unit tests

### `tests/agents/test_suffix_constraints.py`

```python
def test_bracket_suffix():
    ctx = make_context(suffix="]")
    constraints = SuffixConstraintAgent().analyze(ctx)

    assert "]" in constraints.must_close
    assert constraints.forbidden_newlines is True


def test_paren_semicolon_suffix():
    ctx = make_context(suffix=");")
    constraints = SuffixConstraintAgent().analyze(ctx)

    assert ")" in constraints.must_not_repeat
    assert constraints.forbidden_newlines is True


def test_empty_suffix():
    ctx = make_context(suffix="")
    constraints = SuffixConstraintAgent().analyze(ctx)

    assert constraints.forbidden_newlines is False
```

---

## 6ï¸âƒ£ How this is used (not yet enforced)

Right now, this agent only **reports** constraints.

Later agents will:

* trim suffix echoes (you already do this)
* block multiline completions
* reject completions that violate constraints
* influence range expansion

Example future usage:

```python
if constraints.forbidden_newlines:
    completion = completion.splitlines()[0]
```

---

## 7ï¸âƒ£ Why this agent is critical

Without suffix constraints, LLMs tend to:

* retype closers
* add blocks inside expressions
* break syntax in subtle ways

With this agent:

* correctness increases
* trimming logic becomes simpler
* prompt instructions can be shorter

---

## 8ï¸âƒ£ You now have the **Cursor Context Trinity**

Youâ€™ve completed:

| Agent                   | Responsibility         |
| ----------------------- | ---------------------- |
| CursorWindowIntentAgent | what is happening      |
| PrefixSemanticAgent     | what exists before     |
| SuffixConstraintAgent   | what must be respected |

This is the **foundation** for:

* RAG
* task agents
* refactors
* safe range edits

---

## Whatâ€™s next (strong recommendation)

Now that context is *fully modeled*, the next step should be:

ğŸ‘‰ **8.1 â€“ RAG: Symbol Index + Retrieval Agent**

Because:

* intent tells *what to retrieve*
* semantics tell *where*
* constraints tell *how much*

If you want, next reply:

> â€œLetâ€™s do 8.1â€

and weâ€™ll design a **local-first, framework-aware RAG** that wonâ€™t pollute inline completions.
