# üß© Step 7.4 ‚Äî Completion Decision & Orchestration Layer

> **Purpose:**
> Convert multiple independent agent signals into **one explicit, explainable decision** about _whether_ and _how_ to complete code.

This layer sits **between analysis agents (7.1‚Äì7.3)** and **generation agents (LLM / CompletionAgent)**.

---

## 1. Position in the pipeline

### Before (current implicit flow)

```
Context
 ‚Üí IntentAgent
 ‚Üí PrefixSemanticAgent
 ‚Üí SuffixConstraintAgent
 ‚Üí CompletionAgent (LLM)
```

### After (explicit, controlled flow)

```
CompletionContext
        ‚îÇ
        ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Analysis Agents     ‚îÇ
‚îÇ  (7.1‚Äì7.3)           ‚îÇ
‚îÇ                      ‚îÇ
‚îÇ  - EditIntent        ‚îÇ
‚îÇ  - PrefixSemantics   ‚îÇ
‚îÇ  - SuffixConstraints ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
          ‚îÇ
          ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Completion Orchestrator    ‚îÇ  ‚Üê 7.4 (NEW)
‚îÇ                            ‚îÇ
‚îÇ  - Merge signals           ‚îÇ
‚îÇ  - Apply rules             ‚îÇ
‚îÇ  - Decide strategy         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
          ‚îÇ
          ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Completion Decision        ‚îÇ
‚îÇ (explicit, inspectable)    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
          ‚îÇ
   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
   ‚ñº                ‚ñº
CompletionAgent   RetrievalAgent (Phase 8)
(LLM)             (RAG, optional)
```

---

## 2. Core concepts introduced in Step 7.4

### 2.1 CompletionStrategy (what kind of completion?)

```python
class CompletionStrategy(Enum):
    NONE               # Do nothing
    INLINE             # Expression / symbol
    BLOCK              # Function, class, control block
    DOCSTRING          # Structured docstring
    REFACTOR_SNIPPET   # Small rewrite
```

This replaces implicit intent ‚Üí generation mapping.

---

### 2.2 CompletionDecision (the contract)

This is **the most important new domain object**.

```python
@dataclass
class CompletionDecision:
    should_complete: bool

    strategy: CompletionStrategy

    confidence: float  # 0.0 ‚Äì 1.0

    max_tokens: int
    allow_multiline: bool

    require_rag: bool

    explanation: str   # human-readable, for debugging later
```

Key rule:

> If something goes wrong, you inspect **this**, not agent internals.

---

## 3. CompletionDecisionInput (what the orchestrator sees)

```python
@dataclass
class CompletionDecisionInput:
    context: CompletionContext

    intent: EditIntent
    semantics: PrefixSemantics
    constraints: SuffixConstraints
```

Important:

- No raw strings
- No LLM knowledge
- Fully deterministic

---

## 4. The Completion Orchestrator

### 4.1 Responsibility (very strict)

The orchestrator **does not generate text**
The orchestrator **does not call LLMs**
The orchestrator **does not retrieve knowledge**

It only:

- weighs signals
- applies rules
- outputs a decision

---

### 4.2 Orchestrator interface

```python
class CompletionOrchestrator(Protocol):
    def decide(
        self,
        input: CompletionDecisionInput
    ) -> CompletionDecision:
        ...
```

One method. One responsibility.

---

## 5. Decision flow (step-by-step logic)

### Step 1 ‚Äî Hard blockers (fail fast)

Examples:

- Constraint forbids completion
- Intent confidence too low
- Cursor inside comment/string (optional rule)

```text
If constraints.disallow_completion:
    should_complete = False
```

---

### Step 2 ‚Äî Intent gating

Map intent ‚Üí strategy:

| Intent type         | Strategy  |
| ------------------- | --------- |
| symbol_completion   | INLINE    |
| argument_completion | INLINE    |
| block_completion    | BLOCK     |
| docstring           | DOCSTRING |
| unknown             | NONE      |

If `intent.confidence < threshold` ‚Üí NONE.

---

### Step 3 ‚Äî Semantic refinement

Use prefix semantics to tune behavior:

Examples:

- In method scope ‚Üí allow multiline blocks
- Known framework ‚Üí likely require RAG later
- Known variables ‚Üí lower token budget

No generation, only tuning.

---

### Step 4 ‚Äî Constraint enforcement

Examples:

- Suffix contains `)` ‚Üí single-line only
- Suffix contains `:` ‚Üí typing context
- Inside array ‚Üí forbid block

This may downgrade:

```
BLOCK ‚Üí INLINE
INLINE ‚Üí NONE
```

---

### Step 5 ‚Äî RAG flag (not retrieval)

Decide **if retrieval would help**, not _do it_.

Examples:

- Framework detected
- Unknown symbol
- Docstring requested

```python
require_rag = (
    strategy in {BLOCK, DOCSTRING}
    and semantics.framework is not None
)
```

---

### Step 6 ‚Äî Final decision object

Everything becomes explicit and explainable.

```python
CompletionDecision(
    should_complete=True,
    strategy=CompletionStrategy.INLINE,
    confidence=0.82,
    max_tokens=24,
    allow_multiline=False,
    require_rag=False,
    explanation="Argument completion inside function call"
)
```

---

## 6. What Step 7.4 deliberately does NOT do

‚ùå No LLM calls
‚ùå No embeddings
‚ùå No RAG
‚ùå No Neovim logic

This keeps it:

- fast
- testable
- deterministic

---

## 7. Testing strategy (important)

Step 7.4 should be **heavily unit-tested**.

### Example tests

- Low intent confidence ‚Üí no completion
- Suffix constraint overrides intent
- Docstring intent ‚Üí DOCSTRING strategy
- Framework detected ‚Üí require_rag=True
- Block intent inside `()` ‚Üí downgraded to INLINE

These tests will become **your safety net** for Phases 8‚Äì12.

---

## 8. Why this unlocks everything later

With 7.4 in place:

- Phase 8 (RAG) becomes a **plug-in**
- Phase 9 agents reuse the same decision contract
- Phase 10 orchestration becomes _extension_, not rewrite
- You can add:
  - deterministic mode
  - explanation UI
  - per-project tuning

---

## 9. Visual summary

```
[ Agents 7.1‚Äì7.3 ]
        ‚îÇ
        ‚ñº
[ CompletionDecisionInput ]
        ‚îÇ
        ‚ñº
[ Completion Orchestrator ]
        ‚îÇ
        ‚ñº
[ CompletionDecision ]
        ‚îÇ
   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
   ‚ñº              ‚ñº
LLM Completion   RAG (Phase 8)
```

---

## Next steps (your call)

Say one:

1. **‚ÄúScaffold Step 7.4 (files + interfaces only)‚Äù**
2. **‚ÄúImplement Step 7.4 fully with tests‚Äù**
3. **‚ÄúAdjust the decision model (fields / rules)‚Äù**
4. **‚ÄúNow move to Phase 8 and design RAG on top of this‚Äù**

You‚Äôre doing this _exactly_ the right way.

--

# üß© Step 7.4 ‚Äî Full Implementation

## Files added

```
ai/orchestrator/
‚îú‚îÄ‚îÄ default_orchestrator.py
tests/
‚îú‚îÄ‚îÄ orchestrator/
‚îÇ   ‚îú‚îÄ‚îÄ test_default_orchestrator.py
```

(Existing scaffold files from the previous step remain unchanged.)

---

## 1Ô∏è‚É£ Default Orchestrator Implementation

### `ai/orchestrator/default_orchestrator.py`

```python
# ai/orchestrator/default_orchestrator.py

from __future__ import annotations

from ai.orchestrator.decision import CompletionDecision
from ai.orchestrator.decision_input import CompletionDecisionInput
from ai.orchestrator.orchestrator import CompletionOrchestrator
from ai.orchestrator.strategy import CompletionStrategy
from domain.intent_types import EditIntentType


class DefaultCompletionOrchestrator(CompletionOrchestrator):
    """
    Deterministic orchestration layer that merges agent signals
    into a single completion decision.

    This class must:
    - be side-effect free
    - never call LLMs or RAG
    - be fully unit-testable
    """

    MIN_INTENT_CONFIDENCE: float = 0.35

    def decide(
        self,
        input: CompletionDecisionInput,
    ) -> CompletionDecision:
        # ---------------------------------------------------------
        # 1. Hard blockers (fail fast)
        # ---------------------------------------------------------
        if input.constraints.disallow_completion:
            return CompletionDecision(
                should_complete=False,
                strategy=CompletionStrategy.NONE,
                confidence=0.0,
                max_tokens=0,
                allow_multiline=False,
                require_rag=False,
                explanation="Suffix constraints disallow completion",
            )

        if input.intent.confidence < self.MIN_INTENT_CONFIDENCE:
            return CompletionDecision(
                should_complete=False,
                strategy=CompletionStrategy.NONE,
                confidence=input.intent.confidence,
                max_tokens=0,
                allow_multiline=False,
                require_rag=False,
                explanation="Intent confidence below threshold",
            )

        # ---------------------------------------------------------
        # 2. Intent ‚Üí initial strategy
        # ---------------------------------------------------------
        strategy = self._strategy_from_intent(input.intent.type)

        if strategy is CompletionStrategy.NONE:
            return CompletionDecision(
                should_complete=False,
                strategy=CompletionStrategy.NONE,
                confidence=input.intent.confidence,
                max_tokens=0,
                allow_multiline=False,
                require_rag=False,
                explanation="Intent does not map to a completion strategy",
            )

        # ---------------------------------------------------------
        # 3. Semantic refinement
        # ---------------------------------------------------------
        allow_multiline = strategy in {
            CompletionStrategy.BLOCK,
            CompletionStrategy.DOCSTRING,
        }

        max_tokens = self._default_max_tokens(strategy)

        # Narrow scope ‚Üí smaller budget
        if input.semantics.scope == "expression":
            max_tokens = min(max_tokens, 32)
            allow_multiline = False

        # ---------------------------------------------------------
        # 4. Constraint enforcement (downgrades)
        # ---------------------------------------------------------
        if input.constraints.force_single_line:
            allow_multiline = False

            if strategy is CompletionStrategy.BLOCK:
                strategy = CompletionStrategy.INLINE

        if input.constraints.forbid_block and strategy is CompletionStrategy.BLOCK:
            strategy = CompletionStrategy.INLINE

        # ---------------------------------------------------------
        # 5. RAG requirement (decision only)
        # ---------------------------------------------------------
        require_rag = (
            strategy in {CompletionStrategy.BLOCK, CompletionStrategy.DOCSTRING}
            and input.semantics.framework is not None
        )

        # ---------------------------------------------------------
        # 6. Final decision
        # ---------------------------------------------------------
        return CompletionDecision(
            should_complete=True,
            strategy=strategy,
            confidence=input.intent.confidence,
            max_tokens=max_tokens,
            allow_multiline=allow_multiline,
            require_rag=require_rag,
            explanation=self._explain(strategy, require_rag),
        )

    # -------------------------------------------------------------
    # Internal helpers
    # -------------------------------------------------------------

    def _strategy_from_intent(
        self,
        intent_type: EditIntentType,
    ) -> CompletionStrategy:
        return {
            EditIntentType.SYMBOL_COMPLETION: CompletionStrategy.INLINE,
            EditIntentType.ARGUMENT_COMPLETION: CompletionStrategy.INLINE,
            EditIntentType.BLOCK_COMPLETION: CompletionStrategy.BLOCK,
            EditIntentType.DOCSTRING: CompletionStrategy.DOCSTRING,
        }.get(intent_type, CompletionStrategy.NONE)

    def _default_max_tokens(
        self,
        strategy: CompletionStrategy,
    ) -> int:
        return {
            CompletionStrategy.INLINE: 24,
            CompletionStrategy.BLOCK: 120,
            CompletionStrategy.DOCSTRING: 160,
            CompletionStrategy.REFACTOR_SNIPPET: 80,
        }.get(strategy, 0)

    def _explain(
        self,
        strategy: CompletionStrategy,
        require_rag: bool,
    ) -> str:
        base = f"Strategy={strategy.value}"
        if require_rag:
            return f"{base}, RAG suggested due to framework context"
        return base
```

---

## 2Ô∏è‚É£ Unit Tests

These tests validate **behavior**, not implementation details.

### `tests/orchestrator/test_default_orchestrator.py`

```python
# tests/orchestrator/test_default_orchestrator.py

from ai.orchestrator.default_orchestrator import DefaultCompletionOrchestrator
from ai.orchestrator.strategy import CompletionStrategy
from ai.orchestrator.decision_input import CompletionDecisionInput

from domain.context import CompletionContext
from domain.intent import EditIntent
from domain.intent_types import EditIntentType
from domain.prefix_semantics import PrefixSemantics
from domain.suffix_constraints import SuffixConstraints


def _base_input(
    *,
    intent_type: EditIntentType,
    intent_confidence: float = 0.9,
    framework: str | None = None,
    disallow_completion: bool = False,
    force_single_line: bool = False,
    forbid_block: bool = False,
) -> CompletionDecisionInput:
    return CompletionDecisionInput(
        context=CompletionContext(
            language="python",
            file_path="test.py",
            cursor_line=1,
            cursor_col=5,
            current_line="foo(",
            previous_lines=[],
            next_lines=[],
        ),
        intent=EditIntent(
            type=intent_type,
            confidence=intent_confidence,
        ),
        semantics=PrefixSemantics(
            variables=["foo"],
            framework=framework,
            scope="expression",
        ),
        constraints=SuffixConstraints(
            disallow_completion=disallow_completion,
            force_single_line=force_single_line,
            forbid_block=forbid_block,
        ),
    )


def test_disallowed_by_constraints():
    orchestrator = DefaultCompletionOrchestrator()
    decision = orchestrator.decide(
        _base_input(
            intent_type=EditIntentType.SYMBOL_COMPLETION,
            disallow_completion=True,
        )
    )

    assert decision.should_complete is False
    assert decision.strategy is CompletionStrategy.NONE


def test_low_intent_confidence_blocks_completion():
    orchestrator = DefaultCompletionOrchestrator()
    decision = orchestrator.decide(
        _base_input(
            intent_type=EditIntentType.SYMBOL_COMPLETION,
            intent_confidence=0.1,
        )
    )

    assert decision.should_complete is False
    assert decision.strategy is CompletionStrategy.NONE


def test_inline_completion_default():
    orchestrator = DefaultCompletionOrchestrator()
    decision = orchestrator.decide(
        _base_input(
            intent_type=EditIntentType.SYMBOL_COMPLETION,
        )
    )

    assert decision.should_complete is True
    assert decision.strategy is CompletionStrategy.INLINE
    assert decision.allow_multiline is False


def test_block_completion():
    orchestrator = DefaultCompletionOrchestrator()
    decision = orchestrator.decide(
        _base_input(
            intent_type=EditIntentType.BLOCK_COMPLETION,
        )
    )

    assert decision.should_complete is True
    assert decision.strategy is CompletionStrategy.BLOCK


def test_block_downgraded_to_inline_by_constraints():
    orchestrator = DefaultCompletionOrchestrator()
    decision = orchestrator.decide(
        _base_input(
            intent_type=EditIntentType.BLOCK_COMPLETION,
            forbid_block=True,
        )
    )

    assert decision.should_complete is True
    assert decision.strategy is CompletionStrategy.INLINE


def test_docstring_triggers_rag_when_framework_present():
    orchestrator = DefaultCompletionOrchestrator()
    decision = orchestrator.decide(
        _base_input(
            intent_type=EditIntentType.DOCSTRING,
            framework="django",
        )
    )

    assert decision.should_complete is True
    assert decision.strategy is CompletionStrategy.DOCSTRING
    assert decision.require_rag is True
```

---

## ‚úÖ What we achieved

- Step 7.4 is now **fully real**
- Behavior is:
  - deterministic
  - explainable
  - unit-tested

- LLMs and RAG are still **completely decoupled**
- Phase 8 can now be added _without touching this logic_

This is a **very strong architectural checkpoint**.

---

## Next (your choice)

Say one:

1. **‚ÄúWire Step 7.4 into the existing completion flow‚Äù**
2. **‚ÄúRefine orchestration rules / thresholds‚Äù**
3. **‚ÄúStart Phase 8: design RAG (interfaces + flow)‚Äù**
4. **‚ÄúStart Phase 8: scaffold RetrievalAgent‚Äù**

You‚Äôre officially past the ‚Äúdanger zone‚Äù now ‚Äî everything ahead compounds cleanly.
