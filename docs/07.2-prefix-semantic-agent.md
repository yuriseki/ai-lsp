# Phase 7.2 â€” Prefix Semantic Agent

Phase **7.2 â€“ Prefix Semantic Agent** is where your system starts *understanding* code instead of just reacting to syntax.

This agent will **extract meaning from text before the cursor** and produce *structured signals* that downstream agents (RAG, completion, refactor) can trust.

No LLMs here. Deterministic. Fast. Testable.


## ğŸ¯ Goal

From the **prefix only**, infer:

* variables in scope (cheap heuristic)
* likely framework (Drupal, Symfony, Laravel, etc.)
* scope kind (function, method, class, global)
* simple type hints (where possible)

This is **semantic hinting**, not parsing.

---

## 1ï¸âƒ£ Data model

Create a new domain object.

### `domain/semantics.py`

```python
from dataclasses import dataclass
from typing import List, Optional


@dataclass
class PrefixSemantics:
    variables: List[str]
    framework: Optional[str]
    scope: str          # "function" | "method" | "class" | "global"
    language: str
```

Keep it small. Youâ€™ll extend later.

---

## 2ï¸âƒ£ Agent interface

### `agents/semantics.py`

```python
from ai_lsp.agents.base import CompletionAgent
from ai_lsp.domain.completion import CompletionContext
from ai_lsp.domain.semantics import PrefixSemantics


class PrefixSemanticAgent(CompletionAgent):
    def analyze(self, context: CompletionContext) -> PrefixSemantics:
        raise NotImplementedError
```

This mirrors your intent agent:

* produces metadata
* no text mutation

---

## 3ï¸âƒ£ Heuristics (PHP / Python friendly)

Weâ€™ll start with **language-agnostic-ish** rules, then specialize.

---

### 3.1 Variable extraction (cheap + effective)

```python
import re

_VAR_PATTERNS = {
    "php": re.compile(r"\$[a-zA-Z_][a-zA-Z0-9_]*"),
    "python": re.compile(r"\b[a-zA-Z_][a-zA-Z0-9_]*\b"),
}
```

Usage:

```python
def _extract_variables(prefix: str, language: str) -> list[str]:
    pattern = _VAR_PATTERNS.get(language)
    if not pattern:
        return []

    vars = pattern.findall(prefix)
    return list(dict.fromkeys(vars))  # preserve order, remove dups
```

---

### 3.2 Framework detection (Drupal first)

```python
def _detect_framework(prefix: str) -> str | None:
    if "\\Drupal::" in prefix or "use Drupal\\" in prefix:
        return "drupal"
    if "Symfony\\" in prefix:
        return "symfony"
    return None
```

This will later feed:

* RAG source selection
* warning-fix agents

---

### 3.3 Scope detection

Simple, reliable heuristics:

```python
def _detect_scope(prefix: str, language: str) -> str:
    if language == "python":
        if "def " in prefix:
            return "function"
        if "class " in prefix:
            return "class"
    if language == "php":
        if "function " in prefix:
            return "function"
        if "class " in prefix:
            return "class"
    return "global"
```

Later you can:

* walk indentation
* check braces

But this is enough for Phase 7.

---

## 4ï¸âƒ£ Full agent implementation

```python
class PrefixSemanticAgent(CompletionAgent):
    def analyze(self, context: CompletionContext) -> PrefixSemantics:
        prefix = context.prefix or ""
        language = context.language or ""

        variables = _extract_variables(prefix, language)
        framework = _detect_framework(prefix)
        scope = _detect_scope(prefix, language)

        return PrefixSemantics(
            variables=variables,
            framework=framework,
            scope=scope,
            language=language,
        )
```

---

## 5ï¸âƒ£ Unit tests

### `tests/agents/test_prefix_semantics.py`

```python
def test_php_variable_extraction():
    ctx = make_context(
        prefix="$a = $node->getTitle(); $b = ",
        language="php",
    )

    semantics = PrefixSemanticAgent().analyze(ctx)

    assert "$a" in semantics.variables
    assert "$node" in semantics.variables


def test_drupal_detection():
    ctx = make_context(
        prefix="\\Drupal::service('foo')",
        language="php",
    )

    semantics = PrefixSemanticAgent().analyze(ctx)

    assert semantics.framework == "drupal"


def test_scope_detection():
    ctx = make_context(
        prefix="class A {\n    function foo() {",
        language="php",
    )

    semantics = PrefixSemanticAgent().analyze(ctx)

    assert semantics.scope == "function"
```

---

## 6ï¸âƒ£ Engine integration (minimal)

In your engine:

```python
context.semantics = self.prefix_semantic_agent.analyze(context)
```

Thatâ€™s it.

No agent depends on this yet â€” but **RAG and fix agents will**.

---

## 7ï¸âƒ£ Why this agent matters more than it looks

This enables:

| Feature           | How                       |
| ----------------- | ------------------------- |
| Smarter prompts   | Variable names included   |
| Better RAG        | Framework-aware retrieval |
| Safer completions | Scope-aware size limits   |
| Fix agents        | Know when DI applies      |

And it does all that **without LLM cost**.

---

## 8ï¸âƒ£ Whatâ€™s next (recommended order)

Now the system knows:

* *what kind* of edit (7.1)
* *what context* exists (7.2)

The next logical step is:

ğŸ‘‰ **8.1 â€“ RAG: Symbol Index + Retrieval Agent**

Thatâ€™s where completions jump in quality.

When youâ€™re ready, say:

> â€œLetâ€™s do 8.1â€

And weâ€™ll design it to be:

* fast
* local-first
* framework-aware
* non-intrusive to inline completion
