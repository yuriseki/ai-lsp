# 5.5 - Cursor-in-the-Middle (CITM) â€“ Phase Plan

Weâ€™ll add **suffix awareness** without breaking:

* single-line completion
* multiline trimming
* existing tests

No LSP changes yet â€” this is **pure agent logic**.

---

## 1ï¸âƒ£ First: define the invariant

With cursor-in-the-middle, the agent must ensure:

> The returned completion **fits exactly between**
> `prefix | completion | suffix`

So the agent must:

1. Remove any **prefix echo**
2. Remove any **suffix echo**
3. Preserve indentation
4. Work for single-line and multiline completions

---

## 2ï¸âƒ£ Context update (you already hinted this ðŸ‘)

You said earlier this belongs in `CompletionContext`. Youâ€™re right.

### Add `suffix`

```python
class CompletionContext:
    language: str
    file_path: str
    prefix: str
    suffix: str              # ðŸ‘ˆ NEW
    current_line: str
    previous_lines: list[str]
    next_lines: list[str]
    indentation: str
    line: int
    character: int
```

### LSP side (mental model)

Cursor example:

```python
print(va|lue)
```

Becomes:

```python
prefix = "print(va"
suffix = "lue)"
```

This is the **edit window**.

---

## 3ï¸âƒ£ RangeAlignmentAgent responsibility (final form)

The agent now owns **three trims**:

| Step        | Purpose                                    |
| ----------- | ------------------------------------------ |
| Prefix trim | Remove echoed prefix                       |
| Line trim   | Remove overlapping lines (previous / next) |
| Suffix trim | Remove echoed suffix                       |

**Order matters**.

---

## 4ï¸âƒ£ Suffix trimming logic (single line first)

### Core idea

If the completion ends with text that matches the **start of the suffix**, remove it.

### Example

```python
prefix  = "$a = "
suffix  = ";"
completion = "$a = foo();"
```

LLM echoed both sides.

We want:

```python
"foo()"
```

---

### Implementation (character-level, safe)

Add this helper:

```python
def _trim_suffix_overlap(completion: str, suffix: str) -> str:
    if not suffix or not completion:
        return completion

    max_overlap = min(len(completion), len(suffix))

    for i in range(max_overlap, 0, -1):
        if completion.endswith(suffix[:i]):
            return completion[:-i]

    return completion
```

This is:

* deterministic
* safe
* order-aware
* no regex
* no heuristics

---

## 5ï¸âƒ£ Multiline suffix trimming

For multiline, suffix only applies to the **last line**.

### Example

```python
completion:
"""
    do_a()
    cleanup()
"""

suffix:
")"
```

We trim only the last line.

### Logic

```python
def _trim_multiline_suffix_overlap(
    completion_lines: list[str],
    suffix: str,
) -> list[str]:
    if not suffix or not completion_lines:
        return completion_lines

    last = completion_lines[-1]
    trimmed = _trim_suffix_overlap(last, suffix)

    if trimmed != last:
        return completion_lines[:-1] + [trimmed]

    return completion_lines
```

---

## 6ï¸âƒ£ Integrating into `RangeAlignmentAgent.after_generation`

### Canonical order (this matters!)

```python
completion = strip_prefix_echo(...)
completion_lines = completion.splitlines()

completion_lines = trim_leading_overlap(...)
completion_lines = trim_trailing_overlap(...)
completion_lines = trim_multiline_suffix_overlap(...)

return "\n".join(completion_lines)
```

Suffix trimming **must be last** â€” otherwise line trimming can hide overlaps.

---

## 7ï¸âƒ£ New unit tests (essential)

### Single-line cursor-in-middle

```python
def test_suffix_overlap_single_line():
    agent = RangeAlignmentAgent()

    context = make_context(
        prefix="print(",
        suffix=")",
    )

    completion = "value)"

    assert agent.after_generation(context, completion) == "value"
```

---

### Multiline suffix trim

```python
def test_suffix_overlap_multiline():
    agent = RangeAlignmentAgent()

    context = make_context(
        prefix="",
        suffix=")",
    )

    completion = "do_a()\ncleanup())"

    result = agent.after_generation(context, completion)

    assert result == "do_a()\ncleanup()"
```

---

## 8ï¸âƒ£ Why this approach scales

This design:

* Works for **inline**, **multiline**, **middle-cursor**
* Matches how editors apply `TextEdit.range`
* Keeps LSP concerns separate from AI logic
* Avoids AST or token dependency (for now)

---

## What NOT to do (you avoided this ðŸ‘)

âŒ Regex-based trimming
âŒ Removing suffix anywhere (must be edge-based)
âŒ Mixing line + char logic
âŒ Trying to solve AST correctness now

---

## Next steps after this (preview)

Once this is stable, the *very next upgrade* is:

### ðŸ§  Intent-aware range narrowing

> Agent decides *how much* of the suffix is editable

Then:

* smart refactors
* function argument completion
* parameter replacement

But first â€” letâ€™s get CITM rock-solid.

---

If you want, next message we can:

* write the **full RangeAlignmentAgent.after_generation**
* or review your implementation
* or wire suffix capture on the LSP side

Your move ðŸš€
