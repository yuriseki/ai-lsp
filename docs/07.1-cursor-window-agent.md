# Phase 7.1 â€” Cursor-Window Agent (Edit Intent Detection)

## ğŸ¯ Goal

Given **prefix + suffix + cursor position**, infer:

> *â€œWhat kind of edit is the user trying to do right now?â€*

This agent:

* **does not generate text**
* **does not modify ranges**
* only **classifies intent**

Think of it as the *router* for everything that follows.

---

## 1ï¸âƒ£ Data model

### `EditIntentType`

```python
from enum import Enum

class EditIntentType(str, Enum):
    INLINE_COMPLETION = "inline_completion"
    ARGUMENT_COMPLETION = "argument_completion"
    BLOCK_COMPLETION = "block_completion"
    DOCSTRING = "docstring"
    SYMBOL_COMPLETION = "symbol_completion"
    UNKNOWN = "unknown"
```

---

### `EditIntent`

```python
from dataclasses import dataclass

@dataclass
class EditIntent:
    type: EditIntentType
    confidence: float
    reason: str
```

* `confidence` â†’ used later to gate risky agents
* `reason` â†’ debug / explainability (hugely useful)

---

## 2ï¸âƒ£ Agent interface

### File

`agents/intent.py` (you already have this â€” good instinct)

```python
from ai_lsp.agents.base import CompletionAgent
from ai_lsp.domain.completion import CompletionContext
from .intent_types import EditIntent, EditIntentType


class CursorWindowIntentAgent(CompletionAgent):
    def detect_intent(self, context: CompletionContext) -> EditIntent:
        raise NotImplementedError
```

This agent **does not** use `before_generation / after_generation`.
It produces *metadata*.

---

## 3ï¸âƒ£ Core heuristics (simple, deterministic, effective)

Weâ€™ll start with **rule-based detection**.
LLMs are *terrible* at this; rules are better.

---

### 3.1 Argument completion

```python
def _is_argument_completion(prefix: str, suffix: str) -> bool:
    return (
        "(" in prefix
        and ")" in suffix
        and prefix.rfind("(") > prefix.rfind(")")
    )
```

Example:

```python
foo(|bar)
```

---

### 3.2 Block completion

```python
def _is_block_completion(context: CompletionContext) -> bool:
    return (
        context.current_line.strip() == ""
        and context.indentation
        and not context.suffix.strip()
    )
```

Example:

```python
def f():
    |
```

---

### 3.3 Docstring

```python
def _is_docstring(prefix: str, suffix: str) -> bool:
    return (
        '"""' in prefix
        and '"""' in suffix
        and prefix.count('"""') % 2 == 1
    )
```

---

### 3.4 Symbol completion

```python
def _is_symbol_completion(prefix: str) -> bool:
    return prefix.rstrip().endswith((".", "->", "::", "$"))
```

---

## 4ï¸âƒ£ Full agent implementation

```python
class CursorWindowIntentAgent(CompletionAgent):
    def detect_intent(self, context: CompletionContext) -> EditIntent:
        prefix = context.prefix or ""
        suffix = context.suffix or ""

        if _is_docstring(prefix, suffix):
            return EditIntent(
                type=EditIntentType.DOCSTRING,
                confidence=0.9,
                reason="Cursor inside docstring block",
            )

        if _is_argument_completion(prefix, suffix):
            return EditIntent(
                type=EditIntentType.ARGUMENT_COMPLETION,
                confidence=0.85,
                reason="Cursor inside parentheses",
            )

        if _is_block_completion(context):
            return EditIntent(
                type=EditIntentType.BLOCK_COMPLETION,
                confidence=0.8,
                reason="Empty indented line",
            )

        if _is_symbol_completion(prefix):
            return EditIntent(
                type=EditIntentType.SYMBOL_COMPLETION,
                confidence=0.7,
                reason="Member access or symbol trigger",
            )

        return EditIntent(
            type=EditIntentType.INLINE_COMPLETION,
            confidence=0.5,
            reason="Fallback inline completion",
        )
```

---

## 5ï¸âƒ£ Unit tests (important)

### `tests/agents/test_cursor_window_intent.py`

```python
def test_argument_completion():
    ctx = make_context(prefix="foo(", suffix="bar)")
    intent = CursorWindowIntentAgent().detect_intent(ctx)
    assert intent.type == EditIntentType.ARGUMENT_COMPLETION


def test_block_completion():
    ctx = make_context(
        current_line="    ",
        prefix="    ",
        suffix="",
        indentation="    ",
    )
    intent = CursorWindowIntentAgent().detect_intent(ctx)
    assert intent.type == EditIntentType.BLOCK_COMPLETION


def test_docstring():
    ctx = make_context(prefix='"""', suffix='"""')
    intent = CursorWindowIntentAgent().detect_intent(ctx)
    assert intent.type == EditIntentType.DOCSTRING


def test_symbol_completion():
    ctx = make_context(prefix="$this->", suffix="")
    intent = CursorWindowIntentAgent().detect_intent(ctx)
    assert intent.type == EditIntentType.SYMBOL_COMPLETION
```

---

## 6ï¸âƒ£ How this plugs into your engine (no refactor)

In `OllamaCompletionEngine.complete`:

```python
intent = self.intent_agent.detect_intent(context)
context.intent = intent
```

Thatâ€™s it.

No other agent breaks.

---

## 7ï¸âƒ£ Why this is a big unlock

With **EditIntent**, you can now:

| Intent              | Effect                |
| ------------------- | --------------------- |
| ARGUMENT_COMPLETION | shrink prompt         |
| BLOCK_COMPLETION    | allow multiline       |
| DOCSTRING           | switch model / prompt |
| SYMBOL_COMPLETION   | RAG symbol lookup     |
| INLINE              | conservative insert   |

This prevents:

* giant completions in arguments
* docstrings appearing mid-line
* unsafe range expansions

---

## 8ï¸âƒ£ What comes next (natural order)

After 7.1, the clean progression is:

### **7.2 Prefix Semantic Agent**

Extract:

* variable names
* types
* framework hints (Drupal)

Then:

### **8.1 RAG Symbol Index**

Now you know *what to retrieve*.

---

### Final note (important)

Youâ€™re doing this **the right way**:

* intent first
* generation last
* agents > prompts

This is exactly how real IDE engines evolve.

When youâ€™re ready, say:

> â€œLetâ€™s do 7.2â€

â€¦and weâ€™ll build it with the same rigor.
